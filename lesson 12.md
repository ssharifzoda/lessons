# –ó–∞–Ω—è—Ç–∏–µ 12: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ Go

"–ü–∏—à–µ–º –Ω–∞–¥–µ–∂–Ω—ã–π –∫–æ–¥ —Å –ø–æ–º–æ—â—å—é unit-—Ç–µ—Å—Ç–æ–≤"

---

## üìù –ü–ª–∞–Ω –Ω–∞ —Å–µ–≥–æ–¥–Ω—è

1. –ó–∞—á–µ–º –Ω—É–∂–Ω–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ? –§–∏–ª–æ—Å–æ—Ñ–∏—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤ Go
2. –ü–∞–∫–µ—Ç testing: –û—Å–Ω–æ–≤—ã –Ω–∞–ø–∏—Å–∞–Ω–∏—è —Ç–µ—Å—Ç–æ–≤
3. Table-driven tests: –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥ –∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—é
4. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ HTTP handlers: Mocking –∏ —Ç–µ—Å—Ç–æ–≤—ã–µ —Å–µ—Ä–≤–µ—Ä—ã
5. –ü–æ–∫—Ä—ã—Ç–∏–µ –∫–æ–¥–∞ (coverage): –ê–Ω–∞–ª–∏–∑ –∫–∞—á–µ—Å—Ç–≤–∞ —Ç–µ—Å—Ç–æ–≤
6. –ü—Ä–∞–∫—Ç–∏–∫–∞: –ü–∏—à–µ–º —Ç–µ—Å—Ç—ã –¥–ª—è —Ä–µ–∞–ª—å–Ω–æ–≥–æ –∫–æ–¥–∞

---

## 1. –ó–∞—á–µ–º –Ω—É–∂–Ω–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ?

–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ - —ç—Ç–æ –ø—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ –∫–æ–¥ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ –≤ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Å—Ü–µ–Ω–∞—Ä–∏—è—Ö.

–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:

¬∑ –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –±–∞–≥–æ–≤ –Ω–∞ —Ä–∞–Ω–Ω–µ–π —Å—Ç–∞–¥–∏–∏<br>
¬∑ –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –ø—Ä–∏ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–µ<br>
¬∑ –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –ø–æ–≤–µ–¥–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–π<br>
¬∑ –ö–∞—á–µ—Å—Ç–≤–æ –∫–æ–¥–∞<br>

–§–∏–ª–æ—Å–æ—Ñ–∏—è Go:

¬∑ –¢–µ—Å—Ç—ã —Ä—è–¥–æ–º —Å –∫–æ–¥–æ–º (—Ñ–∞–π–ª—ã _test.go)<br>
¬∑ –ú–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π —Ñ—Ä–µ–π–º–≤–æ—Ä–∫<br>
¬∑ –ü—Ä–æ—Å—Ç–æ—Ç–∞ –Ω–∞–ø–∏—Å–∞–Ω–∏—è —Ç–µ—Å—Ç–æ–≤<br>

---

## 2. –ü–∞–∫–µ—Ç testing - –æ—Å–Ω–æ–≤—ã

–°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞:

```go
// calculator.go
package calculator

func Add(a, b int) int {
    return a + b
}

func Multiply(a, b int) int {
    return a * b
}
```

```go
// calculator_test.go
package calculator

import "testing"

// –¢–µ—Å—Ç —Ñ—É–Ω–∫—Ü–∏–∏ Add
func TestAdd(t *testing.T) {
    result := Add(2, 3)
    expected := 5
    
    if result != expected {
        t.Errorf("Add(2, 3) = %d; expected %d", result, expected)
    }
}

// –¢–µ—Å—Ç —Ñ—É–Ω–∫—Ü–∏–∏ Multiply
func TestMultiply(t *testing.T) {
    result := Multiply(4, 5)
    expected := 20
    
    if result != expected {
        t.Errorf("Multiply(4, 5) = %d; expected %d", result, expected)
    }
}
```

–ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤:

bash

### –ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö —Ç–µ—Å—Ç–æ–≤ –≤ –ø–∞–∫–µ—Ç–µ
```
go test
```

### –ó–∞–ø—É—Å–∫ —Å –ø–æ–¥—Ä–æ–±–Ω—ã–º –≤—ã–≤–æ–¥–æ–º
```
go test -v
```

### –ó–∞–ø—É—Å–∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞
```
go test -v -run TestAdd
```

---

## 3. Table-driven tests

Table-driven tests - –ø–æ–¥—Ö–æ–¥, –∫–æ–≥–¥–∞ —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –≤—ã–Ω–æ—Å—è—Ç—Å—è –≤ —Ç–∞–±–ª–∏—Ü—É.

```go
func TestAdd_TableDriven(t *testing.T) {
    tests := []struct {
        name     string
        a        int
        b        int
        expected int
    }{
        {"positive numbers", 2, 3, 5},
        {"negative numbers", -1, -1, -2},
        {"mixed numbers", -5, 10, 5},
        {"zero", 0, 0, 0},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Add(tt.a, tt.b)
            if result != tt.expected {
                t.Errorf("Add(%d, %d) = %d; expected %d", 
                    tt.a, tt.b, result, tt.expected)
            }
        })
    }
}
```
---

## 4. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫

–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–π, –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∏—Ö –æ—à–∏–±–∫–∏:
```go
// math.go
package math

import "errors"

var ErrDivisionByZero = errors.New("division by zero")

func Divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, ErrDivisionByZero
    }
    return a / b, nil
}
```

```go
// math_test.go
package math

import "testing"

func TestDivide(t *testing.T) {
    tests := []struct {
        name        string
        a           float64
        b           float64
        expected    float64
        expectError bool
    }{
        {"normal division", 10.0, 2.0, 5.0, false},
        {"division by zero", 10.0, 0.0, 0.0, true},
        {"fraction result", 1.0, 2.0, 0.5, false},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result, err := Divide(tt.a, tt.b)
            
            if tt.expectError {
                if err == nil {
                    t.Error("expected error, but got nil")
                }
                if err != ErrDivisionByZero {
                    t.Errorf("expected ErrDivisionByZero, got %v", err)
                }
            } else {
                if err != nil {
                    t.Errorf("unexpected error: %v", err)
                }
                if result != tt.expected {
                    t.Errorf("Divide(%f, %f) = %f; expected %f", 
                        tt.a, tt.b, result, tt.expected)
                }
            }
        })
    }
}
```
---

## 5. –ü–æ–∫—Ä—ã—Ç–∏–µ –∫–æ–¥–∞ (Coverage)

–ê–Ω–∞–ª–∏–∑ –ø–æ–∫—Ä—ã—Ç–∏—è —Ç–µ—Å—Ç–∞–º–∏:

### –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤ —Å –∞–Ω–∞–ª–∏–∑–æ–º –ø–æ–∫—Ä—ã—Ç–∏—è
```go test -cover```

### –°–æ–∑–¥–∞–Ω–∏–µ –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –æ—Ç—á–µ—Ç–∞ –ø–æ–∫—Ä—ã—Ç–∏—è
```go test -coverprofile=coverage.out```

```go tool cover -html=coverage.out```


–ü—Ä–∏–º–µ—Ä –æ—Ç—á–µ—Ç–∞ –ø–æ–∫—Ä—ã—Ç–∏—è:

PASS<br>
coverage: 85.7% of statements<br>
ok      calculator 0.002s

---

## üéØ –ü—Ä–∞–∫—Ç–∏–∫–∞ 1: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —É—Ç–∏–ª–∏—Ç –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å–æ —Å—Ç—Ä–æ–∫–∞–º–∏

–ó–∞–¥–∞—á–∞: –ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å–æ —Å—Ç—Ä–æ–∫–∞–º–∏

```go
// string_utils.go
package utils

import "strings"

func Reverse(s string) string {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}

func CountVowels(s string) int {
    vowels := "aeiou–∞–µ—ë–∏–æ—É—ã—ç—é—èAEIOU–ê–ï–Å–ò–û–£–´–≠–Æ–Ø"
    count := 0
    for _, char := range s {
        if strings.ContainsRune(vowels, char) {
            count++
        }
    }
    return count
}

func IsPalindrome(s string) bool {
    cleaned := strings.ToLower(strings.ReplaceAll(s, " ", ""))
    return cleaned == Reverse(cleaned)
}
```

```go
// string_utils_test.go
package utils

import "testing"

func TestReverse(t *testing.T) {
    tests := []struct {
        name     string
        input    string
        expected string
    }{
        {"empty string", "", ""},
        {"single character", "a", "a"},
        {"ascii string", "hello", "olleh"},
        {"unicode string", "–ø—Ä–∏–≤–µ—Ç", "—Ç–µ–≤–∏—Ä–ø"},
        {"with spaces", "hello world", "dlrow olleh"},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Reverse(tt.input)
            if result != tt.expected {
                t.Errorf("Reverse(%q) = %q; expected %q", 
                    tt.input, result, tt.expected)
            }
        })
    }
}

func TestCountVowels(t *testing.T) {
    tests := []struct {
        name     string
        input    string
        expected int
    }{
        {"no vowels", "bcdfg", 0},
        {"english vowels", "hello world", 3},
        {"russian vowels", "–ø—Ä–∏–≤–µ—Ç –º–∏—Ä", 4},
        {"mixed case", "Hello World", 3},
        {"empty string", "", 0},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := CountVowels(tt.input)
            if result != tt.expected {
                t.Errorf("CountVowels(%q) = %d; expected %d", 
                    tt.input, result, tt.expected)
            }
        })
    }
}

func TestIsPalindrome(t *testing.T) {
    tests := []struct {
        name     string
        input    string
        expected bool
    }{
        {"empty string", "", true},
        {"single character", "a", true},
        {"palindrome ascii", "racecar", true},
        {"palindrome russian", "–∫–∞–∑–∞–∫", true},
        {"not palindrome", "hello", false},
        {"with spaces", "–∞ —Ä–æ–∑–∞ —É–ø–∞–ª–∞ –Ω–∞ –ª–∞–ø—É –∞–∑–æ—Ä–∞", true},
        {"case insensitive", "Racecar", true},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := IsPalindrome(tt.input)
            if result != tt.expected {
                t.Errorf("IsPalindrome(%q) = %t; expected %t", 
                    tt.input, result, tt.expected)
            }
        })
    }
}
```
---

## üéØ –ü—Ä–∞–∫—Ç–∏–∫–∞ 2: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä –∏ –º–µ—Ç–æ–¥–æ–≤

–ó–∞–¥–∞—á–∞: –ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–∏—Å—Ç–µ–º—É —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–∞–Ω–∫–æ–≤—Å–∫–∏–º —Å—á–µ—Ç–æ–º

```go
// bank.go
package bank

import (
    "errors"
    "fmt"
)

var (
    ErrInsufficientFunds = errors.New("insufficient funds")
    ErrInvalidAmount     = errors.New("invalid amount")
)

type Account struct {
    owner   string
    balance float64
}

func NewAccount(owner string, initialBalance float64) (*Account, error) {
    if initialBalance < 0 {
        return nil, ErrInvalidAmount
    }
    return &Account{owner: owner, balance: initialBalance}, nil
}

func (a *Account) Deposit(amount float64) error {
    if amount <= 0 {
        return ErrInvalidAmount
    }
    a.balance += amount
    return nil
}

func (a *Account) Withdraw(amount float64) error {
    if amount <= 0 {
        return ErrInvalidAmount
    }
    if amount > a.balance {
        return ErrInsufficientFunds
    }
    a.balance -= amount
    return nil
}

func (a *Account) Balance() float64 {
    return a.balance
}

func (a *Account) Owner() string {
    return a.owner
}

func (a *Account) Transfer(amount float64, to *Account) error {
    if err := a.Withdraw(amount); err != nil {
        return err
    }
    return to.Deposit(amount)
}
```

```go
// bank_test.go
package bank

import (
    "testing"
)

func TestNewAccount(t *testing.T) {
    tests := []struct {
        name          string
        owner         string
        initialBalance float64
        expectedError bool
    }{
        {"valid account", "Alice", 100.0, false},
        {"zero balance", "Bob", 0.0, false},
        {"negative balance", "Charlie", -50.0, true},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            acc, err := NewAccount(tt.owner, tt.initialBalance)
            
            if tt.expectedError {
                if err == nil {
                    t.Error("expected error, but got nil")
                }
            } else {
                if err != nil {
                    t.Errorf("unexpected error: %v", err)
                }
                if acc.Owner() != tt.owner {
                    t.Errorf("expected owner %q, got %q", tt.owner, acc.Owner())
                }
                if acc.Balance() != tt.initialBalance {
                    t.Errorf("expected balance %.2f, got %.2f", 
                        tt.initialBalance, acc.Balance())
                }
            }
        })
    }
}

func TestAccount_Deposit(t *testing.T) {
    acc, _ := NewAccount("Test", 100.0)
    
    tests := []struct {
        name          string
        amount        float64
        expectedBalance float64
        expectedError bool
    }{
        {"valid deposit", 50.0, 150.0, false},
        {"zero deposit", 0.0, 100.0, true},
        {"negative deposit", -10.0, 100.0, true},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            initialBalance := acc.Balance()
            err := acc.Deposit(tt.amount)
            
            if tt.expectedError {
                if err == nil {
                    t.Error("expected error, but got nil")
                }
                if acc.Balance() != initialBalance {
                    t.Error("balance should not change on error")
                }
            } else {
                if err != nil {
                    t.Errorf("unexpected error: %v", err)
                }
                if acc.Balance() != tt.expectedBalance {
                    t.Errorf("expected balance %.2f, got %.2f", 
                        tt.expectedBalance, acc.Balance())
                }
            }
        })
    }
}

func TestAccount_Withdraw(t *testing.T) {
    acc, _ := NewAccount("Test", 100.0)
    
    tests := []struct {
        name          string
        amount        float64
        expectedBalance float64
        expectedError bool
    }{
        {"valid withdraw", 30.0, 70.0, false},
        {"withdraw zero", 0.0, 100.0, true},
        {"withdraw negative", -10.0, 100.0, true},
        {"insufficient funds", 150.0, 100.0, true},
        {"withdraw all", 100.0, 0.0, false},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            initialBalance := acc.Balance()
            err := acc.Withdraw(tt.amount)
            
            if tt.expectedError {
                if err == nil {
                    t.Error("expected error, but got nil")
                }
                if acc.Balance() != initialBalance {
                    t.Error("balance should not change on error")
                }
            } else {
                if err != nil {
                    t.Errorf("unexpected error: %v", err)
                }
                if acc.Balance() != tt.expectedBalance {
                    t.Errorf("expected balance %.2f, got %.2f", 
                        tt.expectedBalance, acc.Balance())
                }
            }
        })
    }
}

func TestAccount_Transfer(t *testing.T) {
    t.Run("successful transfer", func(t *testing.T) {
        alice, _ := NewAccount("Alice", 100.0)
        bob, _ := NewAccount("Bob", 50.0)
        
        err := alice.Transfer(30.0, bob)
        if err != nil {
            t.Errorf("unexpected error: %v", err)
        }
        
        if alice.Balance() != 70.0 {
            t.Errorf("expected Alice balance 70.0, got %.2f", alice.Balance())
        }
        
        if bob.Balance() != 80.0 {
            t.Errorf("expected Bob balance 80.0, got %.2f", bob.Balance())
        }
    })
    
    t.Run("insufficient funds for transfer", func(t *testing.T) {
        alice, _ := NewAccount("Alice", 30.0)
        bob, _ := NewAccount("Bob", 50.0)
        
        err := alice.Transfer(50.0, bob)
        if err != ErrInsufficientFunds {
            t.Errorf("expected ErrInsufficientFunds, got %v", err)
        }
        
        // Balances should not change
        if alice.Balance() != 30.0 {
            t.Error("Alice balance should not change on failed transfer")
        }
        if bob.Balance() != 50.0 {
            t.Error("Bob balance should not change on failed transfer")
        }
    })
}
```
